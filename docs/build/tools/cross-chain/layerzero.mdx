---
id: layerzero
title: LayerZero
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Layerzero 

## Introduction <a id="introduction"></a>

Over the past years in the blockchain space, data and tokens transfer between independent blockchain systems stands as a major challenge. However, with the advent of cross-chain messaging protocols like LayerZero, we have seen a major progress in connecting isolated systems together in a secure and decentralized manner. Now, tokens can be transferred from one ecosystem to another seamlessly in one transaction call without having to go through conversion in different exchanges.

By the end of this guide, you will have transferred tokens from Kairos Testnet to Base Sepolia in a single transaction call using LayerZero V2 Omnichain Fungible Token (OFT) Contract.

![](/img/build/tools/lz-v2-banner.png)

## Prerequisites <a id="prerequisites"></a>

Before delving into the entire project, it's important to note that its finished form can be found in this repository: [crosschain-oft-v2-example](https://github.com/ayo-klaytn/crosschain-oft-v2-example). It uses Hardhat, so a prerequisite knowledge will be helpful for understanding how the repository works. Note that this tutorial will not include information on how to use Hardhat and will instead focus solely on the smart contracts. If you would like to follow along, the prerequisites are as follows:

* [Knowledge of how to use Hardhat](../../get-started/hardhat.md)
* Test Funds from both [Kairos Testnet Faucet](https://faucet.kaia.io/) and [Base Sepolia Faucet](https://faucets.chain.link/base-sepolia)

## Getting Started <a id="getting-started"></a>

In this guide, we will use LayerZero V2 Omnichain Fungible Tokens (OFT) to facilitate cross-chain token transfer across EVM chains seamlessly. LayerZero provides the [create-lz-oapp](https://github.com/LayerZero-Labs/devtools) CLI toolkit, which we will use to easily build, configure, and deploy our omnichain applications (OApps) on both Kairos Testnet (source chain) and Base Sepolia (destination chain).

## Setting Up Your LayerZero Project <a id="setting-up-your-layerzero-project"></a>

 Follow this [guide](https://docs.layerzero.network/v2/developers/evm/create-lz-oapp/start#setting-up-your-layerzero-project) to bootstrap your initial LayerZero project 

## Customizing the OFT Contract <a id="customizing-oft-contract"></a>

Having successfully initialized our OApp, we should see an initial `MyOFT.sol` file in our **contracts** folder. For this guide, we will be deploying this contract on the chains we want the token to exist on. However, we need to modify the MyOFT.sol to have ERC20 `_mint` method as a protected `mintTo` function before deploying.

`MyOFT.sol` should now look like this:

```sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.22;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {OFT} from "@layerzerolabs/oft-evm/contracts/OFT.sol";


/// @notice OFT is an ERC-20 token that extends the OFTCore contract.
contract MyOFT is OFT {
    constructor(
        string memory _name,
        string memory _symbol,
        address _lzEndpoint,
        address _delegate
    ) OFT(_name, _symbol, _lzEndpoint, _delegate) Ownable(_delegate) {}

    function mintTo(address _to, uint256 _amount) public onlyOwner {
        _mint(_to, _amount);
    }
}

```


## Configuring .env file <a id="configuring-env-file"></a>

In this section, we will set up deployer wallet/account for our project. Follow the steps below to configure your `.env`

* Rename `.env.example` -> `.env`
* Choose your preferred means of setting up your deployer wallet/account:

	```ts
		MNEMONIC="test test test test test test test test test test test junk"
		or...
		PRIVATE_KEY="0xabc...def" // use this
	```
* Use the faucet link in the prerequisite section to fund this address with the native tokens of the corresponding chain you wish to deploy.


## Project Configuration <a id="project-configuration"></a>

Follow this [guide](https://docs.layerzero.network/v2/developers/evm/create-lz-oapp/project-config) to set up your project configuration. 

Your `hardhat.config.ts` and `layerzero.config.ts` should look like this to suit the networks we will be working with:

<Tabs>
  <TabItem value="hardhat-config-ts" label="hardhat.config.ts">

```ts
  networks: {
        'kairos-testnet': {
            eid: EndpointId.KLAYTN_V2_TESTNET,
            url: process.env.RPC_URL_KAIROS || 'https://public-en-kairos.node.kaia.io',
            accounts,
        },
        'base-sep-testnet': {
            eid: EndpointId.BASESEP_V2_TESTNET,
            url: process.env.RPC_URL_BASE_SEP || 'https://base-sepolia.blockpi.network/v1/rpc/public',
            accounts,
        },
    },

```

  </TabItem>

  <TabItem value="layerzero-config-ts" label="layerzero.config.ts">

```ts
// layerzero.config.ts

import { EndpointId } from '@layerzerolabs/lz-definitions'
import type { OmniPointHardhat } from '@layerzerolabs/toolbox-hardhat'

// Define the Kairos Testnet contract
// eid specifies the network (LZ V2 Kairos Testnet)
// contractName is the name of the contract.
const kairosContract: OmniPointHardhat = {
    eid: EndpointId.KLAYTN_V2_TESTNET,
    contractName: 'MyOFT',
}


// Define the Base Sepolia contract
// eid specifies the network (LZ V2 Base Sepolia)
// contractName is the name of the contract.
const baseSepContract: OmniPointHardhat = {
    eid: EndpointId.BASESEP_V2_TESTNET,
    contractName: 'MyOFT',
}
```

  </TabItem>
</Tabs>


:::info

The only notable change from a standard `hardhat.config.ts` setup is the inclusion of a [LayerZero Endpoint ID](https://docs.layerzero.network/v2/developers/evm/technical-reference/deployed-contracts).

:::

After defining what contracts to use on each network, you can specify which contracts should be connected on a per pathway basis:

```ts
// layerzero.config.ts

import type { OAppOmniGraphHardhat } from '@layerzerolabs/toolbox-hardhat'


const config: OAppOmniGraphHardhat = {
    contracts: [
        {
            contract: kairosContract,
        },
        {
            contract: baseSepContract,
        },
    ],
    connections: [
        {
            from: kairosContract,
            to: baseSepContract,
        },
        {
            from: baseSepContract,
            to: kairosContract,
        },
    ],
}

export default config

```

## Deploying LayerZero Contract <a id="deploying-layerzero-contract"></a>

Follow this [guide](https://docs.layerzero.network/v2/developers/evm/create-lz-oapp/deploying) to deploy your OFT contract on Kairos Testnet (source chain) and Base Sepolia (destination chain) respectively. 

After following the prompt command, you should see the following in your terminal:

```sh
Network: base-sep-testnet
Deployer: 0x0000000000000000000000000000000000000000
Network: kairos-testnet
Deployer: 0x0000000000000000000000000000000000000000
Deployed contract: MyOFT, network: base-sep-testnet, address: 0x02657Bc72D9AFB778bf3edd14De1997cD46eF7a1
Deployed contract: MyOFT, network: kairos-testnet, address: 0x5907191DbEd1E7ad03F3F69f2134973fd07dD545
info:    ✓ Your contracts are now deployed
```
A deployments folder containing your contracts:

```sh
contracts / // your contracts folder
  deploy / // hardhat-deploy scripts
  deployments / // your hardhat-deploy deployments
  base-sep-testnet / // network name defined in hardhat.config.ts
  MyOFT.json; // deployed-contract json
kairos-testnet / MyOFT.json;
test / // unit-tests, both hardhat and foundry enabled
  foundry.toml; // normal foundry.toml for remappings and project configuration
hardhat.config.ts; // standard hardhat.config.ts, with layerzero endpoint mappings
layerzero.config.ts; // special LayerZero config file

```


## Configuring LayerZero Contracts <a id="configuring-layerzero-contracts"></a>

In this section, we will modify our LayerZero contracts to have unique configurations on a per-pathway basis (i.e., `from Kairos Testnet to Base Sepolia` has different properties than `from Base Sepolia to Kairos Testnet`) as such, modifying the `config` of the pathway in our `layerzero.config.ts`.


For each pathway in our `config` file, we get to configure the following:

```sh
FromOApp.setPeer(dstEid, peer)
FromOApp.setEnforcedOptions()
EndpointV2.setSendLibrary(OApp, dstEid, newLib)
EndpointV2.setReceiveLibrary(OApp, dstEid, newLib, gracePeriod)
EndpointV2.setReceiveLibraryTimeout(OApp, dstEid, lib, gracePeriod)
EndpointV2.setConfig(OApp, sendLibrary, sendConfig)
EndpointV2.setConfig(OApp, receiveLibrary, receiveConfig)
EndpointV2.setDelegate(delegate)
```

To add a specific pathway configuration, add a `config: {}` to your connection like this:

```ts
//layerzero.config.ts

import { EndpointId } from '@layerzerolabs/lz-definitions'

import { ExecutorOptionType } from '@layerzerolabs/lz-v2-utilities'

import type { OAppOmniGraphHardhat, OmniPointHardhat } from '@layerzerolabs/toolbox-hardhat'

const kairosContract: OmniPointHardhat = {
    eid: EndpointId.KLAYTN_V2_TESTNET,
    contractName: 'MyOFT',
}

const baseSepContract: OmniPointHardhat = {
    eid: EndpointId.BASESEP_V2_TESTNET,
    contractName: 'MyOFT',
}

const config: OAppOmniGraphHardhat = {
    contracts: [
        {
            contract: kairosContract,
        },
        {
            contract: baseSepContract,
        },
    ],
    connections: [
        {
            from: kairosContract,
            to: baseSepContract,
            // Optional Configuration
            config: {
                // Required Send Library Address on Kairos Testnet
                sendLibrary: '0x6bd925aA58325fba65Ea7d4412DDB2E5D2D9427d',
                receiveLibraryConfig: {
                    // Required Receive Library Address on Kairos Testnet
                    receiveLibrary: '0xFc4eA96c3de3Ba60516976390fA4E945a0b8817B',
                    // Optional Grace Period for Switching Receive Library Address on BSC
                    gracePeriod: BigInt(0),
                },
                // Optional Send Configuration
                // @dev Controls how the `from` chain sends messages to the `to` chain.
                sendConfig: {
                    executorConfig: {
                        maxMessageSize: 10000,
                        // The configured Executor address on Kairos Testnet
                        executor: '0xddF3266fEAa899ACcf805F4379E5137144cb0A7D',
                    },
                    ulnConfig: {
                        // The number of block confirmations to wait on Kairos Testnet before emitting the message from the source chain (Kairos).
                        confirmations: BigInt(0),
                        // The address of the DVNs you will pay to verify a sent message on the source chain (Kairos).
                        // The destination tx will wait until ALL `requiredDVNs` verify the message.
                        requiredDVNs: ["0xe4fe9782b809b7d66f0dcd10157275d2c4e4898d"],
                        // The address of the DVNs you will pay to verify a sent message on the source chain (Kairos).
                        // The destination tx will wait until the configured threshold of `optionalDVNs` verify a message.
                        optionalDVNs: [],
                        // The number of `optionalDVNs` that need to successfully verify the message for it to be considered Verified.
                        optionalDVNThreshold: 0,
                    },
                },
                // Optional Receive Configuration
                // @dev Controls how the `from` chain receives messages from the `to` chain.
                receiveConfig: {
                    ulnConfig: {
                        // The number of block confirmations to expect from the `to` chain (Base Sepolia).
                        confirmations: BigInt(0),
                        // The address of the DVNs your `receiveConfig` expects to receive verifications from on the `from` chain (Kairos Testnet).
                        // The `from` chain's OApp will wait until the configured threshold of `requiredDVNs` verify the message.
                        requiredDVNs: ["0xe4fe9782b809b7d66f0dcd10157275d2c4e4898d"],
                        // The address of the `optionalDVNs` you expect to receive verifications from on the `from` chain (Kairos Testnet).
                        // The destination tx will wait until the configured threshold of `optionalDVNs` verify the message.
                        optionalDVNs: [],
                        // The number of `optionalDVNs` that need to successfully verify the message for it to be considered Verified.
                        optionalDVNThreshold: 0,
                    },
                },
                // Optional Enforced Options Configuration
                // @dev Controls how much gas to use on the `to` chain, which the user pays for on the source `from` chain.
                enforcedOptions: [
                    {
                        msgType: 1,
                        optionType: ExecutorOptionType.LZ_RECEIVE,
                        gas: 60000,
                        value: 0,
                    },
                    {
                        msgType: 1,
                        optionType: ExecutorOptionType.NATIVE_DROP,
                        amount: 0,
                        receiver: '0x1C42aCcd92d491DB8b083Fa953B5E3D9A9E42aD5', // PASTE YOUR RECEIVER ADDRESS
                    },
                    {
                        msgType: 2,
                        optionType: ExecutorOptionType.LZ_RECEIVE,
                        gas: 60000,
                        value: 1,
                    },
                    {
                        msgType: 2,
                        optionType: ExecutorOptionType.COMPOSE,
                        index: 0,
                        gas: 50000,
                        value: 0,
                    },
                ],
            },
        },
        {
            from: baseSepContract,
            to: kairosContract,
        },
    ],
}

export default config

```

Each pathway contains a `config`, containing multiple configuration structs for changing how your OApp sends and receives messages, specifically for the chain your OApp is sending from:

1. **SendLibrary**: Address used for configuring sent messages : This specifies the library (e.g., SendUln302.sol) used for all outgoing messages from the chain.

2. **ReceiveLibraryConfig**: Struct for receiving messages : Contains the receive library address (e.g., ReceiveUln302.sol) and an optional grace period for updates.

3. **ReceiveLibraryTimeoutConfig**: Optional struct for migration : Defines when the old receive library will expire during version migration.

4. **SendConfig**: Struct controlling message sending : Includes executorConfig and ulnConfig (for DVNs), managing how the OApp sends messages.

5. **ReceiveConfig**: Struct controlling message reception : Focuses on ulnConfig (for DVNs), managing how the OApp receives messages.

6. **EnforcedOptions**: Struct for gas management : Controls minimum destination gas for different message types in the OApp.

For more information on configuring LayerZero contracts, kindly refer to this [guide](https://docs.layerzero.network/v2/developers/evm/create-lz-oapp/configuring-pathways#final-config).

Now that we have configured our contract pathways, we can wire them together using this command:

```sh
npx hardhat lz:oapp:wire --oapp-config layerzero.config.ts
```

```sh
info:    [OApp] Checking OApp configuration
info:    [OApp] Checking OApp delegates configuration
info:    [OApp] ✓ Checked OApp delegates
info:    [OApp] Checking OApp peers configuration
info:    [OApp] ✓ Checked OApp peers configuration
info:    [OApp] Checking send libraries configuration
info:    [OApp] ✓ Checked send libraries configuration
info:    [OApp] Checking receive libraries configuration
info:    [OApp] ✓ Checked receive libraries configuration
info:    [OApp] Checking receive library timeout configuration
info:    [OApp] ✓ Checked receive library timeout configuration
info:    [OApp] Checking send configuration
info:    [OApp] ✓ Checked send configuration
info:    [OApp] Checking receive configuration
info:    [OApp] ✓ Checked receive configuration
info:    [OApp] Checking enforced options
info:    [OApp] ✓ Checked enforced options
info:    [OApp] Checking OApp callerBpsCap configuration
info:    [OApp] ✓ Checked OApp callerBpsCap configuration
info:    [OApp] ✓ Checked OApp configuration
info:    There are 7 transactions required to configure the OApp
✔ Would you like to preview the transactions before continuing? … no
✔ Would you like to submit the required transactions? … yes
info:    Successfully sent 7 transactions
info:    ✓ Your OApp is now configured
```

## Calling `send` <a id="calling-send"></a>

In this section, we will send tokens from Kairos Testnet to Base Sepolia using the `send` logic. To do this, we have to create an hardhat task in our `hardhat.config.ts`. 


```ts
import {task} from 'hardhat/config';
import {getNetworkNameForEid, types} from '@layerzerolabs/devtools-evm-hardhat';
import {EndpointId} from '@layerzerolabs/lz-definitions';
import {addressToBytes32} from '@layerzerolabs/lz-v2-utilities';
import {Options} from '@layerzerolabs/lz-v2-utilities';
import {BigNumberish, BytesLike} from 'ethers';

interface Args {
  amount: string;
  to: string;
  toEid: EndpointId;
}

interface SendParam {
  dstEid: EndpointId; // Destination endpoint ID, represented as a number.
  to: BytesLike; // Recipient address, represented as bytes.
  amountLD: BigNumberish; // Amount to send in local decimals.
  minAmountLD: BigNumberish; // Minimum amount to send in local decimals.
  extraOptions: BytesLike; // Additional options supplied by the caller to be used in the LayerZero message.
  composeMsg: BytesLike; // The composed message for the send() operation.
  oftCmd: BytesLike; // The OFT command to be executed, unused in default OFT implementations.
}

task('lz:oft:send', 'Sends tokens from MyOFT')
    .addParam('to', 'Recipient address on the destination chain', undefined, types.string)
    .addParam('toEid', 'Destination endpoint ID', undefined, types.eid)
    .addParam('amount', 'Amount to transfer in token decimals', undefined, types.string)
    .setAction(async (taskArgs: Args, hre) => {
        const { ethers, deployments } = hre
        const { to, toEid, amount } = taskArgs

        console.log(`Network: ${hre.network.name}`)

        const oftDeployment = await deployments.get('MyOFT')
        const [signer] = await ethers.getSigners()
        const oftContract = new ethers.Contract(oftDeployment.address, oftDeployment.abi, signer)

        // Check token balance
        const balance = await oftContract.balanceOf(signer.address)
        const decimals = await oftContract.decimals()
        const amountInWei = ethers.utils.parseUnits(amount, decimals)
        console.log(`Token balance: ${ethers.utils.formatUnits(balance, decimals)}`)
        console.log(`Attempting to send: ${amount}`)

        if (balance.lt(amountInWei)) {
            console.error('Insufficient token balance')

            // Check if signer is the owner and can mint
            const owner = await oftContract.owner()
            if (owner.toLowerCase() === signer.address.toLowerCase()) {
                console.log('You are the owner. Attempting to mint tokens...')
                const mintTx = await oftContract.mintTo(signer.address, amountInWei)
                await mintTx.wait()
                console.log(`Minted ${amount} tokens to your address`)
            } else {
                console.error('You are not the owner and cannot mint tokens. Please acquire tokens before sending.')
                return
            }
        }

        // Prepare send parameters
        const sendParam = {
            dstEid: toEid,
            to: addressToBytes32(to),
            amountLD: amountInWei,
            minAmountLD: amountInWei,
            extraOptions: Options.newOptions().addExecutorLzReceiveOption(65000, 0).toBytes(),
            composeMsg: '0x',
            oftCmd: '0x',
        }

        // Get the quote for the send operation
        const feeQuote = await oftContract.quoteSend(sendParam, false)
        const nativeFee = feeQuote.nativeFee

        console.log(`Sending ${amount} token(s) to ${to} on network ${getNetworkNameForEid(toEid)} (${toEid})`)
        console.log(`Estimated fee: ${ethers.utils.formatEther(nativeFee)} native tokens`)

        // Check if signer has enough native tokens for the fee
        const nativeBalance = await signer.getBalance()
        if (nativeBalance.lt(nativeFee)) {
            console.error(`Insufficient native tokens. You need at least ${ethers.utils.formatEther(nativeFee)}`)
            return
        }

        try {
            const tx = await oftContract.send(sendParam, { nativeFee, lzTokenFee: 0 }, signer.address, {
                value: nativeFee,
            })
            console.log(`Transaction sent. Hash: ${tx.hash}`)
            console.log(`See transaction on LayerZero Scan: https://testnet.layerzeroscan.com/tx/${tx.hash}`)
            await tx.wait()
            console.log('Transaction confirmed')
        } catch (error) {
            // @ts-ignore
            console.error('Transaction failed:', error.message)
            // @ts-ignore
            if (error.data) {
                // @ts-ignore
                console.error('Error data:', error.data)
            }
        }
    })

```

This task automates the process of sending tokens cross-chain using LayerZero's Omnichain Fungible Token (OFT) standard. Firstly, it connects to the specified network and retrieves the `MyOFT` contract. The task then performs a series of crucial checks and preparations: it verifies the sender's token balance, mints additional tokens if needed (and if the sender is the contract owner), constructs the necessary transaction parameters, and estimates the required transaction fee. Once all prerequisites are met, the task executes the cross-chain transfer by calling the OFT contract's `send` function with the appropriate parameters.

Run the command below to execute the task:

```sh
npx hardhat lz:oft:send --network kairos-testnet --to 0x1C42aCcd92d491DB8b083Fa953B5E3D9A9E42aD5 --to-eid 40245 --amount 10

```

```sh
Network: kairos-testnet
Token balance: 0.0
Attempting to send: 10
Insufficient token balance
You are the owner. Attempting to mint tokens...
Minted 10 tokens to your address
Sending 10 token(s) to 0x1C42aCcd92d491DB8b083Fa953B5E3D9A9E42aD5 on network base-sep-testnet (40245)
Estimated fee: 1.594471565548511489 native tokens
Transaction sent. Hash: 0xb102724387fa0a0c902c60b076f4e476e12990a53c9b8e77f54ce96ac08ecef8
See transaction on LayerZero Scan: https://testnet.layerzeroscan.com/tx/0xb102724387fa0a0c902c60b076f4e476e12990a53c9b8e77f54ce96ac08ecef8 
Transaction confirmed
```

You can verify the cross-chain transaction by pasting the transaction hash in [LayerZero Scan](https://testnet.layerzeroscan.com/).

![](/img/build/tools/lz-scan-v2.png)


## Conclusion

Congratulations! 🥳 You were able to successfully send tokens from Kairos Testnet to Base Sepolia in a single transaction call using the LayerZero Omnichain Contract OFT V2. You can take it a step further by setting up a simple user interface to make it easy for users to move tokens between chains. Once token contracts are set up, you can use a web3 library such as [kaia-sdk](https://docs.kaia.io/references/sdk/ethers-ext/getting-started/) or [ethers.js](https://docs.ethers.org/v5/) to connect the `send()` function to a user interface.

Start building with [crosschain-oft-v2-example](https://github.com/ayo-klaytn/crosschain-oft-v2-example) to bootstrap your own projects such as cross-chain decentralized exchanges, cross-chain lending, etc. For more in-depth guides on LayerZero, please refer to the [LayerZero Docs](https://docs.layerzero.network/v2/developers/evm/oft/quickstart) and [LayerZero Github Repository](https://github.com/LayerZero-Labs/devtools/tree/main/examples).